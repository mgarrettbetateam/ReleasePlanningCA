<!-- Release Planning Widget - Self-contained with prominent filter dropdowns -->
 
<template>
    <div class="enhanced-parts-planner">
        <!-- Header with Title (always shown - this is the internal widget header) -->
        <v-card-title class="planner-header">
            <v-icon left color="primary">mdi-clipboard-list</v-icon>
            {{ widgetTitle }}
            <v-spacer />
            <v-chip 
                color="success" 
                small
                outlined
            >
                <v-icon small left>mdi-cloud</v-icon>
                API Data
            </v-chip>
        </v-card-title>

        <!-- Universal Filter Controls -->
        <UniversalFilterControls
            title="Filter Controls"
            subtitle="Select your criteria to view data"
            :filters="filterConfig"
            :filter-values="filterValues"
            @filter-change="handleFilterChange"
        />

        <!-- Dedicated Data Type Switcher - separate from filter controls -->
        <div class="data-type-switcher-container">
            <div class="data-type-label">Data Type:</div>
            <div class="data-type-switcher">
                <v-btn-toggle
                    v-model="currentDataTypeIndex"
                    mandatory
                    dense
                    color="primary"
                    @change="onDataTypeToggleChange"
                >
                    <v-btn
                        v-for="(dataType, index) in getAvailableDataTypes()"
                        :key="dataType"
                        :value="index"
                        small
                        class="data-type-btn"
                    >
                        {{ dataType.toUpperCase() }}
                    </v-btn>
                </v-btn-toggle>
            </div>
        </div>

        <!-- Charts and Tables Section -->
        <v-row class="content-section">
            <!-- Line Chart Widget - Full Width -->
            <v-col cols="12">
                <v-card class="chart-card" :loading="loading" elevation="4">
                    <v-card-title class="chart-header">
                        <v-icon left color="primary" size="28">mdi-chart-line</v-icon>
                        <span class="chart-title">Cumulative Release Timeline</span>
                        <v-spacer />
                        <div class="chart-meta">
                            <v-chip 
                                small 
                                color="primary" 
                                outlined
                                class="mr-2"
                            >
                                <v-icon small left>mdi-chart-bell-curve</v-icon>
                                {{ chartData.datasets?.[0]?.data?.length || 0 }} Points
                            </v-chip>
                            <v-chip 
                                small 
                                color="success" 
                                outlined
                            >
                                <v-icon small left>mdi-calendar-range</v-icon>
                                Live Data
                            </v-chip>
                        </div>
                    </v-card-title>
                    
                    <!-- Move legend here, inside the chart card but below the header -->
                    <div class="legend-container legend-row chart-legend-inside" style="margin-bottom:0;">
                        <div class="legend-item clickable-legend" :class="{ 'legend-disabled': !showTargetLine }">
                            <div class="legend-color-bar" style="background-color: #1976d2;" :style="{ opacity: showTargetLine ? 1 : 0.3 }"></div>
                            <span class="legend-label" :style="{ opacity: showTargetLine ? 1 : 0.5 }" @click="toggleTargetLine">
                                Target Releases
                                <v-btn
                                    icon
                                    x-small
                                    class="legend-eye-btn"
                                    tabindex="-1"
                                    :color="showTargetLine ? 'primary' : 'grey'"
                                    @click.stop="toggleTargetLine"
                                >
                                    <v-icon small>{{ showTargetLine ? 'mdi-eye' : 'mdi-eye-off' }}</v-icon>
                                </v-btn>
                            </span>
                        </div>
                        <div class="legend-item clickable-legend" :class="{ 'legend-disabled': !showActualLine }">
                            <div class="legend-color-bar" style="background-color: #4caf50;" :style="{ opacity: showActualLine ? 1 : 0.3 }"></div>
                            <span class="legend-label" :style="{ opacity: showActualLine ? 1 : 0.5 }" @click="toggleActualLine">
                                Actual Releases
                                <v-btn
                                    icon
                                    x-small
                                    class="legend-eye-btn"
                                    tabindex="-1"
                                    :color="showActualLine ? 'success' : 'grey'"
                                    @click.stop="toggleActualLine"
                                >
                                    <v-icon small>{{ showActualLine ? 'mdi-eye' : 'mdi-eye-off' }}</v-icon>
                                </v-btn>
                            </span>
                        </div>
                    </div>
                    
                    <v-card-text class="chart-content-wrapper">
                        <div class="chart-container">
                            <UniversalChart
                                v-if="chartDataFromFiltered.labels && chartDataFromFiltered.labels.length > 0"
                                :key="chartKey"
                                :data="chartDataFromFiltered"
                                :options="dynamicChartOptions"
                                type="line"
                                :height="420"
                            />
                            <div v-else class="no-chart-data">
                                <div class="no-data-icon">
                                    <v-icon size="64" color="grey lighten-2">mdi-chart-line-variant</v-icon>
                                </div>
                                <h3 class="no-data-title">No Chart Data Available</h3>
                                <p class="no-data-description">
                                    Try adjusting your filter selections to see timeline data
                                </p>
                                <v-btn
                                    color="primary"
                                    outlined
                                    small
                                    @click="refreshData"
                                >
                                    <v-icon small left>mdi-refresh</v-icon>
                                    Refresh Data
                                </v-btn>
                            </div>
                        </div>
                    </v-card-text>
                </v-card>
            </v-col>

            <!-- Headliners and Table Side by Side -->
            <v-col cols="12" md="3">
                <v-card class="headliners-card">
                    <v-card-title class="headliners-header compact-header">
                        <v-icon left color="info" size="20">mdi-star</v-icon>
                        <span class="compact-title">Release Headliners</span>
                        <v-spacer />
                        <div class="headliner-chips">
                            <v-chip 
                                v-if="selectedStatFilter !== 'all'" 
                                x-small 
                                color="primary" 
                                class="mr-1"
                                @click="filterByReleaseStatus('all')"
                            >
                                <v-icon x-small left>mdi-filter-off</v-icon>
                                Clear
                            </v-chip>
                            <v-chip x-small color="info" outlined>
                                {{ filteredTableData.length }} 
                                {{ selectedStatFilter === 'all' ? 'Total' : getFilterDisplayName(selectedStatFilter) }}
                            </v-chip>
                        </div>
                    </v-card-title>
                  
                    <v-card-text class="headliners-content compact-content">
                        <div v-if="releaseStats" class="stats-grid compact-grid">
                            <div 
                                class="stat-item compact-stat" 
                                :class="{ 
                                    'clickable-stat': releaseStats.releasedCount > 0,
                                    'stat-active': selectedStatFilter === 'released',
                                    'stat-disabled': releaseStats.releasedCount === 0
                                }"
                                @click="releaseStats.releasedCount > 0 ? filterByReleaseStatus('released') : null"
                            >
                                <div class="stat-number compact-number">{{ releaseStats.releasedCount }}</div>
                                <div class="stat-label compact-label">Released</div>
                            </div>
                            <div 
                                class="stat-item compact-stat" 
                                :class="{ 
                                    'clickable-stat': releaseStats.thisWeekCount > 0,
                                    'stat-active': selectedStatFilter === 'thisWeek',
                                    'stat-disabled': releaseStats.thisWeekCount === 0
                                }"
                                @click="releaseStats.thisWeekCount > 0 ? filterByReleaseStatus('thisWeek') : null"
                            >
                                <div class="stat-number compact-number">{{ releaseStats.thisWeekCount }}</div>
                                <div class="stat-label compact-label">This Week</div>
                            </div>
                            <div 
                                class="stat-item compact-stat" 
                                :class="{ 
                                    'clickable-stat': releaseStats.nextWeekCount > 0,
                                    'stat-active': selectedStatFilter === 'nextWeek',
                                    'stat-disabled': releaseStats.nextWeekCount === 0
                                }"
                                @click="releaseStats.nextWeekCount > 0 ? filterByReleaseStatus('nextWeek') : null"
                            >
                                <div class="stat-number compact-number">{{ releaseStats.nextWeekCount }}</div>
                                <div class="stat-label compact-label">Next Week</div>
                            </div>
                            <div 
                                class="stat-item compact-stat" 
                                :class="{ 
                                    'clickable-stat': releaseStats.overdueCount > 0,
                                    'stat-active': selectedStatFilter === 'overdue',
                                    'stat-disabled': releaseStats.overdueCount === 0
                                }"
                                @click="releaseStats.overdueCount > 0 ? filterByReleaseStatus('overdue') : null"
                            >
                                <div class="stat-number compact-number">{{ releaseStats.overdueCount }}</div>
                                <div class="stat-label compact-label">Overdue</div>
                            </div>
                            <div 
                                class="stat-item compact-stat" 
                                :class="{ 
                                    'clickable-stat': releaseStats.next30DaysCount > 0,
                                    'stat-active': selectedStatFilter === 'next30Days',
                                    'stat-disabled': releaseStats.next30DaysCount === 0
                                }"
                                @click="releaseStats.next30DaysCount > 0 ? filterByReleaseStatus('next30Days') : null"
                            >
                                <div class="stat-number compact-number">{{ releaseStats.next30DaysCount }}</div>
                                <div class="stat-label compact-label">Next 30 Days</div>
                            </div>
                            <div 
                                class="stat-item compact-stat clickable-stat" 
                                :class="{ 'stat-active': selectedStatFilter === 'all' }"
                                @click="filterByReleaseStatus('all')"
                            >
                                <div class="stat-number compact-number">{{ releaseStats.totalCount }}</div>
                                <div class="stat-label compact-label">Total</div>
                            </div>
                        </div>
                        <div v-else class="no-stats-message">
                            <v-icon color="grey">mdi-chart-bar</v-icon>
                            <p class="caption">No statistics available</p>
                        </div>
                    </v-card-text>
                </v-card>
            </v-col>
            <v-col cols="12" md="9">
                <v-card class="table-card" :loading="loading">
                    <v-card-title class="table-header">
                        <v-icon left>mdi-table</v-icon>
                        {{ currentDataType.toUpperCase() }} Data Table
                        <v-spacer />
                        <v-chip small color="success" outlined class="mr-2">
                            {{ filteredTableData.length }} Items
                        </v-chip>
                      
                        <!-- Export Button -->
                        <v-menu v-if="filteredTableData.length > 0" bottom left>
                            <template #activator="{ on, attrs }">
                                <v-btn
                                    icon
                                    small
                                    color="primary"
                                    class="export-btn"
                                    title="Export Data"
                                    v-bind="attrs"
                                    v-on="on"
                                >
                                    <v-icon small>mdi-download</v-icon>
                                </v-btn>
                            </template>
                            <v-list>
                                <v-list-item @click="exportTableData('pdf')">
                                    <v-list-item-icon>
                                        <v-icon>mdi-file-pdf-box</v-icon>
                                    </v-list-item-icon>
                                    <v-list-item-title>Export as PDF</v-list-item-title>
                                </v-list-item>
                                <v-list-item @click="exportTableData('csv')">
                                    <v-list-item-icon>
                                        <v-icon>mdi-file-delimited</v-icon>
                                    </v-list-item-icon>
                                    <v-list-item-title>Export as CSV</v-list-item-title>
                                </v-list-item>
                            </v-list>
                        </v-menu>
                    </v-card-title>
                  
                    <v-card-text class="table-content">
                        <v-data-table
                            v-if="filteredTableData.length > 0"
                            :headers="tableHeaders"
                            :items="filteredTableData"
                            :loading="loading"
                            dense
                            :items-per-page="10"
                            :footer-props="{ itemsPerPageOptions: [5, 10, 25, 50] }"
                            item-value="partNo"
                            @click:row="handleRowClick"
                        >
                            <template #body="{ items }">
                                <tbody>
                                    <tr
                                        v-for="(item, index) in items"
                                        :key="item.partNo || item.caNumber || item.crNumber || item.itemNumber || index"
                                        @click="handleRowClick(item)"
                                    >
                                        <td v-for="header in tableHeaders" :key="header.value">
                                            <!-- Use ChangeActionCell component for CA fields (only in parts data) -->
                                            <ChangeActionCell
                                                v-if="header.component === 'ChangeActionCell'"
                                                :obj-id="item.physId"
                                                :row-index="index"
                                                :field="header.componentProps.field"
                                                @ca-number-loaded="onCaNumberLoaded"
                                            />
                                            <!-- Regular cell for all other data -->
                                            <span v-else>{{ item[header.value] || 'N/A' }}</span>
                                        </td>
                                    </tr>
                                </tbody>
                            </template>
                        </v-data-table>
                        <div v-else class="no-data-message">
                            <v-icon size="48" color="grey">mdi-table-off</v-icon>
                            <p>No table data available for current filters</p>
                            <p class="caption">Try adjusting your filter selections</p>
                        </div>
                    </v-card-text>
                </v-card>
            </v-col>
        </v-row>
    </div>
</template>

<style scoped>
/* Component-specific styles that can't be moved to global CSS */
.chart-content,
.table-content {
  flex: 1;
  display: flex;
  flex-direction: column;
}

.chart-card {
  min-height: 480px;
  height: 100%;
  display: flex;
  flex-direction: column;
}

.chart-content-wrapper {
  flex: 1;
  padding: 0 24px 24px 24px;
  display: flex;
  align-items: stretch;
}

.chart-container {
  flex: 1;
  min-height: 400px;
  height: 100%;
  display: flex;
  flex-direction: column;
}

/* Ensure all filter dropdowns (program, phase, organization) are visually consistent in size */
.universal-filter-controls .v-select,
.universal-filter-controls .v-input,
.universal-filter-controls .v-select__slot {
  min-width: 320px !important;
  width: auto !important;
  max-width: none !important;
  box-sizing: border-box;
  height: 44px !important;
  min-height: 44px !important;
  line-height: 44px !important;
  white-space: nowrap !important;
}

/* Ensure the input and label inside the dropdown are vertically centered */
.universal-filter-controls .v-input__slot,
.universal-filter-controls .v-select__selections {
  height: 44px !important;
  min-height: 44px !important;
  display: flex;
  align-items: center;
}

/* Optional: Adjust the label and icon for vertical alignment */
.universal-filter-controls .v-label,
.universal-filter-controls .v-icon {
  margin-top: 0 !important;
  display: flex;
  align-items: center;
}

/* Make sure the filter content stays on one line and is centered vertically */
.universal-filter-controls .v-select__slot {
  display: flex;
  flex-wrap: nowrap;
  align-items: center;
}

/* Ensure labels aren't wrapping */
.universal-filter-controls .v-select__selection {
  white-space: nowrap !important;
  max-width: 180px !important;
  overflow: hidden !important;
  text-overflow: ellipsis !important;
}

/* Headliner Stats Styling */
.stats-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
}

.stat-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 16px 8px;
  border-radius: 4px;
  background-color: #f5f5f5;
  transition: all 0.2s ease;
}

.clickable-stat {
  cursor: pointer;
}

.clickable-stat:hover {
  background-color: #e0e0e0;
  transform: translateY(-2px);
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.stat-active {
  background-color: #e3f2fd;
  border: 1px solid #2196f3;
}

.stat-disabled {
  opacity: 0.6;
  cursor: default;
}

.stat-disabled:hover {
  background-color: #f5f5f5;
  transform: none;
  box-shadow: none;
}

.stat-number {
  font-size: 24px;
  font-weight: 700;
  color: #333;
  line-height: 1.2;
  margin-bottom: 4px;
}

.stat-label {
  font-size: 14px;
  color: #666;
  text-align: center;
}

/* Compact version for smaller spaces */
.compact-stat {
  padding: 8px 4px;
}

.compact-number {
  font-size: 20px;
}

.compact-label {
  font-size: 12px;
}

.no-stats-message {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 32px 16px;
  color: #9e9e9e;
  text-align: center;
}

/* No chart data styling */
.no-chart-data {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  min-height: 200px;
  color: #9e9e9e;
  text-align: center;
}

.no-data-icon {
  margin-bottom: 16px;
}

.no-data-title {
  font-size: 18px;
  margin-bottom: 8px;
  color: #666;
}

.no-data-description {
  margin-bottom: 16px;
  max-width: 300px;
}

/* Legend styling */
.legend-container {
  display: flex;
  align-items: center;
  margin: 0 24px 16px;
}

.legend-row {
  flex-direction: row;
  gap: 24px;
}

.legend-item {
  display: flex;
  align-items: center;
  cursor: default;
}

.clickable-legend {
  cursor: pointer;
}

.legend-disabled {
  opacity: 0.7;
}

.legend-color-bar {
  width: 24px;
  height: 3px;
  margin-right: 8px;
  border-radius: 1px;
}

.legend-label {
  font-size: 14px;
  display: flex;
  align-items: center;
}

.legend-eye-btn {
  margin-left: 4px;
  opacity: 0.7;
}

.legend-eye-btn:hover {
  opacity: 1;
}

/* Move legend inside chart card */
.chart-legend-inside {
  padding: 0px 24px;
  margin-bottom: 8px !important;
}

/* Improve spacing around filter controls */
.universal-filter-controls {
  margin-bottom: 12px;
}

/* Data type switcher for better visual separation */
.data-type-switcher-container {
  margin-bottom: 20px;
}

/* Slight adjustments for headers */
.planner-header, .chart-header, .table-header {
  padding-top: 16px;
  padding-bottom: 16px;
}

/* Compact headliners header */
.compact-header {
  padding: 12px 16px !important;
  min-height: auto !important;
}

.compact-title {
  font-size: 16px !important;
}

.headliner-chips {
  display: flex;
  align-items: center;
}

/* Set minimum content height */
.content-section {
  min-height: 400px;
}

/* Ensure all cards have consistent elevation */
.chart-card, .table-card, .headliners-card {
  box-shadow: 0 2px 4px rgba(0,0,0,0.1) !important;
  border-radius: 4px;
  overflow: hidden;
  height: 100%;
  display: flex;
  flex-direction: column;
}

/* Make sure chart title is properly sized */
.chart-title {
  font-size: 18px;
  font-weight: 500;
}

/* Chart meta info (points count, etc) */
.chart-meta {
  display: flex;
  align-items: center;
}

/* Export button styling */
.export-btn {
  opacity: 0.7;
  transition: opacity 0.2s ease;
}

.export-btn:hover {
  opacity: 1;
}

/* Ensure the enhanced-parts-planner container has proper spacing */
.enhanced-parts-planner {
  padding: 0;
  height: 100%;
  display: flex;
  flex-direction: column;
}

/* Make sure headliners card content has proper spacing */
.headliners-content {
  padding: 8px !important;
}

/* No data message for tables */
.no-data-message {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 48px 16px;
  text-align: center;
  color: #9e9e9e;
}

/* Ensure v-data-table has full height */
.v-data-table {
  flex: 1;
  display: flex;
  flex-direction: column;
}
</style>

<script>
/* eslint-disable no-console */
import UniversalChart from "@/components/universal/UniversalChart.vue";
import UniversalFilterControls from "@/components/universal/UniversalFilterControls.vue";
import ChangeActionCell from "@/components/release-planning/ChangeActionCell.vue";
import dataService from "@/data/DataServiceBase.js";
import { USE_MOCK_DATA } from "@/config/ApiConfig.js";

export default {
    name: "EnhancedPartsPlannerWidget",
    components: {
        UniversalChart,
        UniversalFilterControls,
        ChangeActionCell
    },
    props: {
        hideHeader: {
            type: Boolean,
            default: false
        }
    },
    data() {
        return {
            // Filter values - consolidated object for UniversalFilterControls
            filterValues: {
                program: "",
                phase: "",
                organization: "All"
            },
            
            // Filter options - will be loaded dynamically
            programs: [],
            phases: [],
            organizations: [],
            
            // Raw data
            tableData: [],
            
            // Data for chart and filtered display
            chartData: { labels: [], datasets: [] },
            chartKey: 0, // Add for forcing chart re-renders
            
            // Current data type being displayed - determines which header configuration to use
            currentDataType: "parts", // "parts", "cas", "crs", etc.
            currentDataTypeIndex: 0, // Index for v-btn-toggle
            
            // Configuration for different data types - easily extensible
            headerConfigurations: {
                parts: [
                    { text: "Part Number", value: "partNo", sortable: true, required: true, icon: "mdi-barcode" },
                    { text: "Rev", value: "rev", sortable: true, icon: "mdi-source-branch" },
                    { text: "Description", value: "description", sortable: true, icon: "mdi-text" },
                    { text: "Organization", value: "organization", sortable: true, icon: "mdi-domain" },
                    { text: "Target Release", value: "tgtRelease", sortable: true, icon: "mdi-calendar-clock" },
                    { text: "Actual Release", value: "actualRelease", sortable: true, icon: "mdi-calendar-check" },
                    { text: "State", value: "currentState", sortable: true, icon: "mdi-flag" },
                    { text: "Change Action", value: "caNumber", sortable: false, component: "ChangeActionCell", componentProps: { field: "number" } },
                    { text: "CA State", value: "caState", sortable: false, component: "ChangeActionCell", componentProps: { field: "state" } }
                ],
                cas: [
                    { text: "CA Number", value: "caNumber", sortable: true, required: true, icon: "mdi-file-document" },
                    // { text: "Rev", value: "revision", sortable: true, icon: "mdi-source-branch" },
                    { text: "Description", value: "changeSummary", sortable: true, icon: "mdi-text" },
                    { text: "Resp Engr", value: "name", sortable: true, icon: "mdi-account" },
                   // { text: "Organization", value: "organization", sortable: true, icon: "mdi-domain" },
                    { text: "Status", value: "currentState", sortable: true, icon: "mdi-flag" },
                    { text: "Target Complete Date", value: "targetReleaseDate", sortable: true, icon: "mdi-calendar-clock" },
                    { text: "Actual Approved Date", value: "approvedDate", sortable: true, icon: "mdi-calendar-check" },
                    { text: "Actual Complete Date", value: "actualReleaseDate", sortable: true, icon: "mdi-calendar-check" }
                ],
                crs: [
                    { text: "CR Number", value: "crNumber", sortable: true, required: true, icon: "mdi-file-document-outline" },
                    { text: "Name", value: "name", sortable: true, icon: "mdi-format-title" },
                    { text: "Resp Engr", value: "respEngr", sortable: true, icon: "mdi-account" },
                    { text: "Status", value: "currentState", sortable: true, icon: "mdi-flag" },
                    { text: "Target Complete Date", value: "targetReleaseDate", sortable: true, icon: "mdi-calendar-plus" },
                    { text: "Actual Approve Date", value: "actualApproveDate", sortable: true, icon: "mdi-calendar-clock" },
                    { text: "Actual Complete Date", value: "actualReleaseDate", sortable: true, icon: "mdi-calendar-check" }
                ]
            },
            
            // UI state
            loading: false,
            lastUpdated: new Date().toLocaleTimeString(),
            
            // Chart line visibility
            showTargetLine: true,
            showActualLine: true,
            
            // Release headliner filter
            selectedStatFilter: "all"
        };
    },
    
    computed: {
        // Dynamic widget title based on current data type
        widgetTitle() {
            const titles = {
                parts: "Release Planning Parts Dashboard",
                cas: "Release Planning CA Dashboard", 
                crs: "Release Planning CR Dashboard"
            };
            
            return titles[this.currentDataType] || "Release Planning Dashboard";
        },

        // Dynamic table headers based on current data type and available data
        tableHeaders() {
            // Get base configuration for current data type
            const baseConfig = this.headerConfigurations[this.currentDataType] || [];
            
            if (!this.tableData || this.tableData.length === 0) {
                // Return only required headers when no data is available
                return baseConfig.filter(h => h.required);
            }

            // Get available fields from the actual data
            const availableFields = Object.keys(this.tableData[0]);
            
            // Filter headers based on available data fields
            const filteredHeaders = baseConfig.filter(headerConfig => {
                // Always include required headers
                if (headerConfig.required) return true;
                
                // Always include component-based headers (like ChangeActionCell)
                if (headerConfig.component) return true;
                
                // Include if the field exists in the data
                return availableFields.includes(headerConfig.value);
            });

            console.log("=== DYNAMIC HEADERS DEBUG ===");
            console.log("Current data type:", this.currentDataType);
            console.log("Available fields in data:", availableFields);
            console.log("Base config headers:", baseConfig.map(h => h.value));
            console.log("Filtered headers:", filteredHeaders.map(h => h.value));
            console.log("Final header count:", filteredHeaders.length);

            return filteredHeaders;
        },

        filterConfig() {
            return [
                {
                    key: "program",
                    label: "Program",
                    icon: "mdi-briefcase",
                    placeholder: "Select Program",
                    options: this.programs,
                    color: "primary"
                },
                {
                    key: "phase",
                    label: "Phase", 
                    icon: "mdi-timeline",
                    placeholder: "Select Phase",
                    options: this.phases,
                    color: "secondary"
                },
                {
                    key: "organization",
                    label: "Organization",
                    icon: "mdi-domain", 
                    placeholder: "Select Organization",
                    options: this.organizations,
                    color: "accent"
                }
            ]
        },
        
        // Directly computes chart data from filtered table data for reactivity
        chartDataFromFiltered() {
            console.log("🔄 [COMPUTED] Computing chart data directly from filteredTableData");
            console.log(`📊 Using ${this.filteredTableData.length} filtered items for chart`);
            
            // Clear chart data if no filtered data is available
            if (!this.filteredTableData || this.filteredTableData.length === 0) {
                console.log("❌ [CHART] No filteredTableData, returning empty chart data");
                return { labels: [], datasets: [] };
            }

            // Work with a copy of the filtered data to avoid mutations
            const currentFilteredData = [...this.filteredTableData];
            
            // Count items with target and actual dates
            let targetDateCount = 0;
            let actualDateCount = 0;
            
            // Collect release dates for both target and actual
            const targetDates = [];
            const actualDates = [];
            
            currentFilteredData.forEach((item) => {
                // Target release dates
                let targetDate = null;
                switch (this.currentDataType) {
                    case "parts":
                        targetDate = item.tgtRelease || item.targetReleaseDate;
                        break;
                    case "cas":
                        targetDate = item.targetReleaseDate;
                        break;
                    case "crs":
                        targetDate = item.dueDate;
                        break;
                    default:
                        targetDate = item.tgtRelease || item.targetReleaseDate || item.dueDate;
                }
                
                if (targetDate && targetDate !== "N/A" && targetDate !== null && targetDate !== "") {
                    try {
                        const dateObj = new Date(targetDate);
                        if (!isNaN(dateObj.getTime())) {
                            targetDates.push({
                                date: dateObj,
                                dateString: dateObj.toLocaleDateString(),
                                item
                            });
                            targetDateCount++;
                        }
                    } catch (error) {
                        console.warn("[DEBUG] Exception parsing targetDate:", targetDate, error);
                    }
                }
                
                // Actual release dates
                let actualDate = null;
                switch (this.currentDataType) {
                    case "parts":
                        actualDate = item.actualRelease || item.actualReleaseDate;
                        break;
                    case "cas":
                        actualDate = item.actualReleaseDate;
                        break;
                    case "crs":
                        actualDate = item.completedDate;
                        break;
                    default:
                        actualDate = item.actualRelease || item.actualReleaseDate || item.completedDate;
                }
                
                if (actualDate && actualDate !== "N/A" && actualDate !== null && actualDate !== "") {
                    try {
                        const dateObj = new Date(actualDate);
                        if (!isNaN(dateObj.getTime())) {
                            actualDates.push({
                                date: dateObj,
                                dateString: dateObj.toLocaleDateString(),
                                item
                            });
                            actualDateCount++;
                        }
                    } catch (error) {
                        console.warn("[DEBUG] Exception parsing actualDate:", actualDate, error);
                    }
                }
            });

            console.log(`[CHART DATA] Found ${targetDateCount} valid target dates and ${actualDateCount} valid actual dates`);
            
            if (targetDates.length === 0 && actualDates.length === 0) {
                console.log("[CHART DATA] No valid release dates found, returning empty chart");
                return { labels: [], datasets: [] };
            }

            // Create a unified timeline covering all dates from both target and actual
            const allDates = new Set();
            targetDates.forEach(item => allDates.add(item.dateString));
            actualDates.forEach(item => allDates.add(item.dateString));
            const sortedDates = Array.from(allDates).sort((a, b) => new Date(a) - new Date(b));
            
            // Create cumulative datasets using the unified timeline
            const createUnifiedCumulativeDataset = (dates, label, color, backgroundColor) => {
                const dateGroups = new Map();
                dates.forEach(release => {
                    const dateStr = release.dateString;
                    if (!dateGroups.has(dateStr)) {
                        dateGroups.set(dateStr, 0);
                    }
                    dateGroups.set(dateStr, dateGroups.get(dateStr) + 1);
                });
                
                const cumulativeData = [];
                let runningTotal = 0;
                sortedDates.forEach(dateStr => {
                    if (dateGroups.has(dateStr)) {
                        runningTotal += dateGroups.get(dateStr);
                    }
                    cumulativeData.push(runningTotal);
                });
                
                return {
                    label,
                    data: cumulativeData,
                    borderColor: color,
                    backgroundColor,
                    tension: 0.2,
                    fill: false,
                    pointRadius: 4,
                    pointHoverRadius: 6,
                    borderWidth: 3
                };
            };
            
            const dataTypeLabels = {
                parts: { target: "Target Parts Release", actual: "Actual Parts Released" },
                cas: { target: "Target CAs Release", actual: "Actual CAs Released" },
                crs: { target: "Target CRs Release", actual: "Actual CRs Released" }
            };
            
            const labels = dataTypeLabels[this.currentDataType] || { target: "Target Items", actual: "Actual Items" };
            const datasets = [];
            
            if (targetDates.length > 0 && this.showTargetLine) {
                const targetDataset = createUnifiedCumulativeDataset(
                    targetDates,
                    labels.target,
                    "#1976d2",
                    "rgba(25, 118, 210, 0.1)"
                );
                datasets.push(targetDataset);
            }
            
            if (actualDates.length > 0 && this.showActualLine) {
                const actualDataset = createUnifiedCumulativeDataset(
                    actualDates,
                    labels.actual,
                    "#4caf50",
                    "rgba(76, 175, 80, 0.1)"
                );
                datasets.push(actualDataset);
            }
            
            const result = {
                labels: sortedDates,
                datasets
            };
            
            console.log(`[CHART GENERATION COMPLETE] Chart created with ${sortedDates.length} date labels and ${datasets.length} datasets`);
            
            return result;
        }
    },
    
    methods: {
        // Chart legend toggle methods
        toggleTargetLine() {
            this.showTargetLine = !this.showTargetLine;
            console.log("Target line visibility toggled:", this.showTargetLine);
            this.$nextTick(() => {
                this.chartKey += 1;
                console.log("Chart key updated after target line toggle:", this.chartKey);
            });
        },
        
        toggleActualLine() {
            this.showActualLine = !this.showActualLine;
            console.log("Actual line visibility toggled:", this.showActualLine);
            this.$nextTick(() => {
                this.chartKey += 1;
                console.log("Chart key updated after actual line toggle:", this.chartKey);
            });
        },
        
        // Handle filter changes from UniversalFilterControls
        handleFilterChange(filterEvent) {
            console.log("🔍 Filter changed:", filterEvent.key, "New value:", filterEvent.value);
            this.filterValues = { ...filterEvent.allFilters };
            
            // Force chart re-render after the filter is applied
            this.$nextTick(() => {
                this.chartKey += 1;
                console.log(`Chart key incremented to ${this.chartKey} after filter change`);
            });
        },
        
        // Filter table data by release status
        filterByReleaseStatus(statusFilter) {
            console.log("====== HEADLINER FILTER CHANGE ======");
            console.log(`Filtering by release status: ${statusFilter}`);
            
            // Update the filter and let Vue's reactivity handle the rest
            this.selectedStatFilter = statusFilter;
            
            // Force chart re-render after the filter is applied
            this.$nextTick(() => {
                this.chartKey += 1;
                console.log(`Chart key incremented to ${this.chartKey} after filter change`);
            });
        },
        
        // Get available data types based on configuration
        getAvailableDataTypes() {
            return Object.keys(this.headerConfigurations);
        },
        
        // Handle data type toggle change
        onDataTypeToggleChange(index) {
            const availableTypes = this.getAvailableDataTypes();
            if (index >= 0 && index < availableTypes.length) {
                this.currentDataType = availableTypes[index];
                console.log(`Data type changed to ${this.currentDataType}`);
                
                // Force chart re-render on data type change
                this.$nextTick(() => {
                    this.chartKey += 1;
                    console.log(`Chart key incremented to ${this.chartKey} after data type change`);
                });
            }
        },
        
        // Apply statistical filter (released, thisWeek, nextWeek, etc.)
        applyStatFilter(data, filterType) {
            if (filterType === 'all') return data;
            
            const now = new Date();
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            const nextWeekStart = new Date(today);
            nextWeekStart.setDate(today.getDate() + 7);
            const nextWeekEnd = new Date(nextWeekStart);
            nextWeekEnd.setDate(nextWeekStart.getDate() + 7);
            const next30Days = new Date(today);
            next30Days.setDate(today.getDate() + 30);
            
            return data.filter(item => {
                const targetDate = new Date(item.tgtRelease || item.targetReleaseDate || item.dueDate);
                const actualDate = new Date(item.actualRelease || item.actualReleaseDate || item.completedDate);
                
                switch (filterType) {
                    case 'released':
                        return !isNaN(actualDate.getTime());
                    case 'thisWeek':
                        return !isNaN(targetDate.getTime()) && 
                               targetDate >= today && 
                               targetDate < nextWeekStart;
                    case 'nextWeek':
                        return !isNaN(targetDate.getTime()) && 
                               targetDate >= nextWeekStart && 
                               targetDate < nextWeekEnd;
                    case 'overdue':
                        return !isNaN(targetDate.getTime()) && 
                               targetDate < today && 
                               isNaN(actualDate.getTime());
                    case 'next30Days':
                        return !isNaN(targetDate.getTime()) && 
                               targetDate >= today && 
                               targetDate <= next30Days;
                    default:
                        return true;
                }
            });
        },
        
        // Helper method to get display name for filter
        getFilterDisplayName(filter) {
            const names = {
                'released': 'Released',
                'thisWeek': 'This Week',
                'nextWeek': 'Next Week',
                'overdue': 'Overdue',
                'next30Days': 'Next 30 Days',
                'all': 'All'
            };
            return names[filter] || filter;
        },
        
        // Refresh data
        refreshData() {
            console.log("Refreshing data...");
            // Implement data refresh logic here
            this.chartKey += 1;
        }
    }
};
</script>
